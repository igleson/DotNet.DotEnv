using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotEnv.SourceGenerator;

[Generator]
public class EnvVarGenerator : IIncrementalGenerator
{
    private const char EqualsChar = '=';
    private const string Underscore = "_";
    private const string CommentLine = "#";
    private static readonly string[] SupportedPropertiesTypes = ["string", "bool", "decimal", "double", "float", "int", "long"];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var dotEnvClassProvider = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (node, _) => IsTargetForGeneration(node),
            transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node);

        var dotEnvFileProvider = context.AdditionalTextsProvider.Where(fileProvider => fileProvider.Path.EndsWith(".env"));

        var valuesProvider = dotEnvFileProvider.Collect().Combine(dotEnvClassProvider.Collect());

        context.RegisterSourceOutput(valuesProvider, (sourceProductionContext, node)
            => Execute(node, sourceProductionContext));
    }

    private static bool IsTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
               && classDeclaration.AttributeLists
                   .SelectMany(attrList => attrList.Attributes)
                   .Any(attr => attr.Name.ToString().Equals("DotEnvAutoGenerated"));
    }

    private static void Execute(
        (ImmutableArray<AdditionalText> DotEnvFileNode, ImmutableArray<ClassDeclarationSyntax> DotEnvClassNode) node,
        SourceProductionContext context)
    {
        if (node.DotEnvFileNode.IsEmpty) return;
        if (node.DotEnvClassNode.IsEmpty) return;

        var fileTexts = node.DotEnvFileNode
            .Select(additionalText => additionalText.GetText()?.ToString())
            .Where(t => t is not null)
            .Select(t => t!)
            .ToList();

        var dict = new Dictionary<string, string>();

        foreach (var line in fileTexts.Select(fileText => fileText.Split('\n')).SelectMany(lines => lines))
        {
            if (line.StartsWith(CommentLine)) continue;
            try
            {
                var l = line.Replace("\r", string.Empty);
                var splitted = l.Split(EqualsChar);
                var name = CultureInfo.InvariantCulture.TextInfo.ToTitleCase(splitted[0].ToLowerInvariant()).Replace(Underscore, string.Empty);

                var value = splitted[1];
                dict.Add(name, value);
            }
            catch
            {
                // ignored
            }
        }

        foreach (var classDeclarationSyntax in node.DotEnvClassNode)
        {
            var propertiesDeclarations = classDeclarationSyntax
                .ChildNodes()
                .OfType<PropertyDeclarationSyntax>()
                .Where(property => property.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PublicKeyword)))
                .Where(property => property.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.StaticKeyword)))
                .Where(PropertyOnlyHasGetAccessor)
                .ToList();

            var propertiesCode =
                string.Join("\n\n\t",
                    propertiesDeclarations
                        .Select(prop =>
                        {
                            if (!dict.TryGetValue(prop.Identifier.ToString(), out var stringfiedValue))
                            {
#pragma warning disable RS1035
                                stringfiedValue = Environment.GetEnvironmentVariable(ToMacroCase(prop.Identifier.ToString()));
#pragma warning restore RS1035
                            }

                            var (propValue, comment) = GenerateValueFor(prop, stringfiedValue);


                            var releasePropValue = propValue ?? $"default; {comment}";

                            if (propValue is not null) return $"public static partial {prop.Type} {prop.Identifier} => {propValue};";

                            return $"""
                                    #if DEBUG
                                        {comment}
                                        #else
                                        public static partial {prop.Type} {prop.Identifier} => {releasePropValue}
                                        #endif
                                    """;
                        })
                        .Where(p => p is not null));

            var @namespace = GetNamespace(classDeclarationSyntax);

            context.AddSource($"{classDeclarationSyntax.Identifier}.g",
                $$"""
                  namespace {{@namespace}};

                  public static partial class {{classDeclarationSyntax.Identifier}}
                  {
                      {{propertiesCode}}
                  }
                  """);
        }
    }

    private static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        var nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        var potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }

    private static bool PropertyOnlyHasGetAccessor(PropertyDeclarationSyntax property)
    {
        var propType = property.Type.ToString().ToLower();
        return SupportedPropertiesTypes.Contains(propType)
               && property.AccessorList?.Accessors.Count == 1
               && property.AccessorList.Accessors.First().Kind() == SyntaxKind.GetAccessorDeclaration;
    }

    public static string ToMacroCase(string value)
    {
        var newIndex = 0;
        var insertSeparator = true;
        var isFirstCharacter = true;
        var current = UnicodeCategory.OtherSymbol;
        var newString = new char[value.Length + CalculateSpanSizeForKebabOrSnakeCase(value)];
        foreach (var c in value)
        {
            var previous = current;
            current = char.GetUnicodeCategory(c);
            insertSeparator = (previous != current && (current is UnicodeCategory.UppercaseLetter || current is UnicodeCategory.DecimalDigitNumber)) || insertSeparator;
            if (IsSpecialCharacter(current)) continue;
            if (insertSeparator && !isFirstCharacter)
            {
                newString[newIndex] = '_';
                newIndex++;
            }
            newString[newIndex] = char.ToUpperInvariant(c);
            isFirstCharacter = false;
            insertSeparator = false;
            newIndex++;
        }
        return new string(newString);
    }
    
    private static int CalculateSpanSizeForKebabOrSnakeCase(string text)
    {
        var previous = char.GetUnicodeCategory(text[0]);
        var skips = IsSpecialCharacter(previous) ? 1 : 0;
        var divs = 0;
        for (var i = 1; i < text.Length; i++)
        {
            var current = char.GetUnicodeCategory(text[i]);
            skips += IsSpecialCharacter(current) ? 1 : 0;
            divs += previous != current && current is UnicodeCategory.UppercaseLetter or UnicodeCategory.DecimalDigitNumber ? 1 : 0;
            previous = current;
        }
        return divs - skips;
    }
    
    private static bool IsSpecialCharacter(UnicodeCategory category)
    {
        return category is not UnicodeCategory.UppercaseLetter
            and not UnicodeCategory.LowercaseLetter
            and not UnicodeCategory.DecimalDigitNumber;
    }
    
    private static (string? value, string? comment) GenerateValueFor(PropertyDeclarationSyntax property, string? stringfiedValue)
    {
        if (string.IsNullOrEmpty(stringfiedValue))
        {
            return (null, "//value is null");
        }

        var propType = property.Type.ToString().ToLower();

        return propType switch
        {
            "string" => ($"\"{stringfiedValue}\"", null),
            "bool" => bool.TryParse(stringfiedValue, out _) ? (stringfiedValue, null) : (null, $"//{stringfiedValue} is not a boolean"),
            "decimal" => decimal.TryParse(stringfiedValue, out var m) ? ($"{m}m", null) : (null, $"//{stringfiedValue} is not a decimal"),
            "double" => double.TryParse(stringfiedValue, out var d) ? ($"{d}d", null) : (null, $"//{stringfiedValue} is not a double"),
            "float" => float.TryParse(stringfiedValue, out var f) ? ($"{f}f", null) : (null, $"//{stringfiedValue} is not a float"),
            "int" => int.TryParse(stringfiedValue, out _) ? (stringfiedValue, null) : (null, $"//{stringfiedValue} is not a integer"),
            "long" => long.TryParse(stringfiedValue, out var l) ? ($"{l}L", null) : (null, $"//{stringfiedValue} is not a long"),
            _ => (null, $"//{propType} is not a supported type")
        };
    }
}